#!/bin/bash
# Author: Luka Ruzic

# using this array makes the different atlases easier to deal with
i=1
while read a; do
    atlas_decoder[i]="$a"
    let i++
done < <(atlasquery --dumpatlases)

usage() {
    echo "
Usage: clustertable <stat_map> [options]

Options:
  -t <Ithr>       clustering will be done with a voxelwise intensity threshold of <Ithr> (default: 2.58)
  -v <Nthr>       only clusters with <Nthr> or more voxels are reported (default: 1)
  -o <filename>   will output to <filename>.csv (DEFAULT: cluster_report_<stat_map>_t<Ithr>_v<Nthr>.csv)
  -neg            report negative intensities (DEFAULT: only positive intensities)
  -lm             generate lines for local maxima
  -d <mm>         only report local maxima separated by <mm> (cluster's --peakdist=<mm> option) (DEFAULT: 0)
  -con <6|18|26>  change which voxels count as connected (in terms of how many count) (cluster's --connectivity=<n> option) (DEFAULT: 26)
  -icbm           use ICBM (Lancaster) coordinate conversion to Talairach space (DEFAULT: Brett conversion)
  -td             append a field containing the readout from the Talairach Daemon
  -a [<atlas code> [...]]
       append a field containing the readout from an FSL atlas
       if no <atlas code> is given, report from Harvard-Oxford atlases
       (example argument: -a 6 7 1)
         ATLAS CODES:"
    for (( i=1; i<${#atlas_decoder[*]} ; i++ )); do echo "            $i: ${atlas_decoder[i]}"; done
    echo "
       NOTE: ATLAS CODES will change dynamically with what atlasquery provides
  -athr <p>
       only report areas that are more than <p>% probable

Description:
  -generates a cluster report for an entire zstat map
  -report includes for every cluster of voxels above the zthreshold:
    -region name (actually the nearest gray matter on a Talairach atlas)
    -Brodmann Area number
    -max statistic
    -number of voxels
    -MNI voxel coordinates of the Max

Note: will work on lower levels, BUT ONLY inside the <analysis>.feat/stats directory
    Tip: to generate reports for all the stat maps in a directory, use clusterall
" >&2

    exit ${1:-1}
}

# Hidden Options:
# in order to keep all the clusters commands in a clusterall from overwriting each other to the no_clusters file
# clusters will look for a --no_clusters_file <file> option so that it can write them all independently, to be concatenated afterwards by clusterall
#    echo "     -odir <dir>      place output files in <dir>"    # this is not publicly viewable because it is only designed for interaction with clusterall



mktempfail() {
    echo "ERROR: failed to create temporary file with mktemp; exiting" >&2
    exit 1
}


### PARSE ARGUMENTS
if [ ! $1 ]; then
    usage
elif [[ "$*" =~ -help ]]; then
    usage
fi

# defaults
Ithr=2.58   # default Z threshold
VOXthr=1   # smallest number of voxels to report on
# read arguments
while [ $1 ]; do
    if [ $1 == "-t" ]&&[ $2 ]; then
	Ithr=$2
	shift 2
    elif [ $1 == "-v" ]&&[ $2 ]; then
	VOXthr=$2
	shift 2
    elif [ $1 == "-o" ]&&[ $2 ]; then
	FOUT=${2%.csv}.csv
	shift 2
    elif [ $1 == "-neg" ]; then
	NEG=set
	shift
    elif [ $(imtest $1) -eq 1 ]; then  # imtest is FSL's image test
	if [ $statmap ]
	then  # one image has already been given
	    echo "ERROR: TOO MANY INPUTS" >&2
	    echo "$zstat" >&2
	    echo "$1" >&2
	    usage
	fi
	statmap=$1
	shift
    elif [ $1 == "-lm" ]; then
	RUNLOCALMAXIMA=1
	shift
    elif [ $1 == "-d" ]&&[ $2 ]; then
	EXTRAOPTS+=" --peakdist=$2"
	shift 2
    elif [ $1 == "-con" ]&&[ $2 ]; then
	EXTRAOPTS+=" --connectivity=$2"
	shift 2
    elif [ $1 == "-icbm" ]; then
	ICBM="-icbm"
	shift
    elif [ "$1" == "-a" ]; then
	while [ $2 ]&&[[ ! "$2" =~ ^- ]]; do
	    if [[ "$2" =~ [^0-9] ]]||[ $2 -lt -0 ]||[ $2 -gt ${#atlas_decoder[*]} ]; then
		echo "ERROR: invalid atlas code: $2"
		exit 1
	    fi
	    ATLAS_CODES+=($2)
	    shift
	done
	# if no codes specified, default to Harvard-Oxford atlases
	if [ ${#ATLAS_CODES[*]} -eq 0 ]; then
	    ATLAS_CODES=($(atlasquery --dumpatlases | awk '/Harvard-Oxford/ {print NR}'))
	fi
	shift
    elif [ "$1" == "-athr" ]; then
	if [ $2 ]&&[[ "$2" =~ ^[0-9]*$ ]]; then
	    ATLAS_THR="$2"
	    shift 2
	else
	    error "INVALID argument to -athr: $2"
	    exit 1
	fi
    elif [ $1 == "-odir" ]&&[ $2 ]; then
	if [ ! -d $2 ]; then
	    echo "cannot find $2"
	else
	    ODIR=$2"/"
	    shift 2
	fi
    elif [ $1 == "-td" ]; then
	TD=set
	shift
    elif [ "$1" == "--no_clusters_file" ]; then
	NOCLUSTERFILE=$2
	shift 2
    else
	echo "UNRECOGNIZED INPUT: $1" >&2
	exit 1
    fi
done


### SET UP
MNI_BRAIN=$(findMNI)
WD=$(mktemp -d "${TMPDIR:-/tmp}/clustertable.XXXX")
HERE=$PWD
[ $NOCLUSTERFILE ] || NOCLUSTERFILE=${HERE}/${ODIR}no_clusters.txt


# discover level (based on image dimensions)
[ $(printf "%.0f" $(fslval $statmap pixdim3)) -eq 2 ] && LEVEL=2 || LEVEL=1


### NAME OUTPUTFILE (if necessary)
if [ ! $FOUT ]; then
    if [ $LEVEL -eq 1 ]; then
	FOUT="${HERE}/${ODIR}cluster_report_$(remove_ext $statmap)_t${Ithr}_v${VOXthr}.csv"
    else                                                        # we're dealing with a higher level (BY FAR the most common usage)
	# if clusters is being run inside a gfeat, include the cope number
	if [ $(echo $HERE | grep -c gfeat) -eq 1 ]; then
	    copeNum=$(pwd | grep -o 'cope[0-9]\{1,2\}')
	    FOUT="${HERE}/${ODIR}cluster_report_${copeNum}_$(remove_ext $statmap)_t${Ithr}_v${VOXthr}.csv"
	else
	    FOUT="${HERE}/${ODIR}cluster_report_$(remove_ext $statmap)_t${Ithr}_v${VOXthr}.csv"
	fi
    fi
fi


### DO CLUSTERING
if [ $LEVEL -eq 1 ]; then  # prepare argument for FLIRT (registration from scanner space to MNI space)
    regopts="-x ../reg/example_func2standard.mat --stdvol=$MNI_BRAIN"
fi

# get cluster information for positive intensities
cluster -i $statmap -t $Ithr $regopts --mm --olmax=$WD/maxima_pos -n 902629 $EXTRAOPTS \
    | awk 'NR>1 && $2>='$VOXthr' {print $2,$3,$4,$5,$6,$1}' > $WD/clusters_pos

# get the first and last index numbers
posindexrange=($(awk '{i=$6} NR==1 {print i} END {print i}' $WD/clusters_pos))
if [ $posindexrange ]; then
    # prune maxima
    awk 'NR==1 {next} $1>='${posindexrange[1]}' {print $0}' $WD/maxima_pos > $WD/maxima_pos_pruned
    mv $WD/maxima_pos{_pruned,}
else
    posindexrange=0
fi

if [ $NEG ]; then
    # invert statmap
    fslmaths $statmap -mul -1 $WD/negstatmap
    
    ## generate information on negative intensities
    # (adjust indexes by adding posindexrange[1] (highest index from positive map) so that they don't overlap with indexes from positive clusters)
    cluster -i $WD/negstatmap -t $Ithr $regopts --mm --olmax=$WD/maxima_neg -n 902629 $EXTRAOPTS \
	| awk 'NR>1 && $2>='$VOXthr' {print $2, $3*-1, $4, $5, $6, $1+'${posindexrange[0]}'}' > $WD/clusters_neg

    # get the first and last index numbers
    negindexrange=($(awk '{i=$6} NR==1 {print i} END {print i}' $WD/clusters_neg))
    if [ $negindexrange ]; then
        # prune/adust maxima
	awk 'NR==1 {next} {$1+='${posindexrange[0]}'} $1>='${negindexrange[1]}' {print $1,$2*-1,$3,$4,$5}' $WD/maxima_neg > $WD/maxima_neg_pruned
	mv $WD/maxima_neg{_pruned,}
    fi
fi


### GENERATE REPORT
# make header
# standard columns
stdcols=",max,nvox,x,y,z"	
# td header
[ $TD ] && td_header=",region,BA"
# atlas titles
for a in ${ATLAS_CODES[*]}; do
    atlas_header+=",${atlas_decoder[a]}"
done
# if reporting local maxima, include cluster index column so that maxima can easily be matched up with their cluster peaks
[ $RUNLOCALMAXIMA ] && indexcol=",index"
# print header
echo ${stdcols}${td_header}${atlas_header}${indexcol} > $FOUT

if [ $(cat $WD/clusters_{pos,neg} 2>/dev/null | wc -l) -ne 0 ]; then
    ### MAKE A LINE OF REPORT PER CLUSTER FOUND
    n=0
    for f in $WD/clusters_{pos,neg}; do
	[ ! -f $f ] && continue

	case ${f##*_} in
	    "pos") printf "POSITIVE:\n" >> $FOUT;;
	    "neg") printf "NEGATIVE:\n" >> $FOUT;;
	esac
	
	while read voxels max x y z i; do
	    let n++
	    clnum[i]=$n
	    
	    # save number of voxels
	    voxels[i]=$voxels
	    
	    if [ $TD ]; then # query tal daemon
		tdfield=($(mm2label $x $y $z $ICBM))
		td_label[i]=","${tdfield[0]}"("${tdfield[1]}"),"${tdfield[2]:-N/A}
	    fi
	    
 	    # output to report
	    [ $ATLAS_CODES ] && atlas_labels="$(mm2label $x $y $z $ICBM -a ${ATLAS_CODES[*]} -athr $ATLAS_THR | while read line; do echo -n ",$line"; done)"
	    
	    [ $RUNLOCALMAXIMA ] && index=",         cluster$i"
	
	    # PRINT
	    echo "${clnum[i]},$max,$voxels,$x,$y,$z${td_label[i]}${atlas_labels}${index}" >> $FOUT
	done < $f
    done
    
    if [ $RUNLOCALMAXIMA ]; then	
	# print more header stuff
	printf "\n\n***LOCAL MAXIMA***\n" >> $FOUT    
	echo ",max,nvox,x,y,z${td_header}${atlas_header},cluster affiliation" >> $FOUT

	nn=0
	for f in $WD/maxima_[pn][oe][sg]; do
	    let nn++
	    if [ $nn -gt 1 ]; then
		printf "NEGATIVES:\n" >> $FOUT
	    fi
            ### REPORT ON LOCAL MAXIMA
	    while read i max x y z; do
		if [ $TD ]; then
	            # get TD labeling
		    [ $NONAME ] || tdfield=($(mm2label $x $y $z $ICBM))
		    [ ${tdfield[0]} ] && maxtdlabel="${tdfield[0]}(${tdfield[1]})" || maxtdlabel="no label"
		fi

	        # get FSL atlas labeling
		[ $ATLAS_CODES] && atlas_labels="$(mm2label $x $y $z $ICBM -a ${ATLAS_CODES[*]} -athr $ATLAS_THR | while read line; do echo -n ",$line"; done)"

                # PRINT
		echo "${clnum[i]},$maxtdlabel,${tdfield[2]},$max,${voxels[i]},$x,$y,$z$atlas_labels,            cluster$i ${td_label[i]}" >> $FOUT
	    done < $f
	done
    fi
    
    echo "generated $FOUT"
    
else ### THERE ARE NO CLUSTERS, ADD TO LIST OF CLUSTERLESS MAPS
    if [ $copeNum ]; then
	echo "no clusters in ${copeNum}, ${statmap}" | tee -a $NOCLUSTERFILE
    else
	echo "no clusters in ${statmap}"  | tee -a $NOCLUSTERFILE
    fi
fi

exit 0
