#!/bin/bash

usage() {
    echo "
Usage: clusterthresh <input_map> [options]
Description: applies voxelwise and clusterwise thresholds to <input_map>
Options:
   -o <filename> call output file <filename>  (DEFAULT: <input_map>.clusters)
   -t <thresh>   do clustering with a voxelwise threshold of <thresh>  (DEFAULT: 2.58)
   -v <thresh>   apply a cluster threshold of <thresh>  (DEFAULT: 1)
   -b            binarize results
   -c            index results (each cluster a different integer intensity (numbered by size)) (positive intensities only)
   -m <table>    create multithresh map with thresholds in <table> (list of t and v thresholds, like clusterthreshes table)
   -pos          only include clusters of positive intensities  (DEFAULT: include neg)

Note: -c option requires python (with numpy and nibabel)
" >&2

    exit ${1:-1}
}


mktempfail() {
    echo "ERROR: mktemp failed to procure temporary file" >&2
    exit 7
}


invert_indices() {
# usage: invert_indices fin fout

python <<EOF
import numpy as np
import nibabel as nib

# load data
img = nib.load('$1')
d = img.get_data()

# invert index ordering (into negatives to avoid overwriting)
n = np.unique(d).max()
for i in np.r_[1:n+1]:
  d[d==i] -= n+1

# invert index sign
for i in np.unique(d):
  d[d==i] *= -1

# write
img.to_filename('$2')

EOF

}


### ERROR-CHECKING
[ $# -lt 1 ] && usage
[[ "$*" =~ -help ]] && usage 1

### PARSE ARGUMENTS
map=$(remove_ext $1); shift
if [ $(imtest $map) == 0 ]; then
    echo "ERROR: not a valid image: $map" >&2
    usage
fi
#fslchfiletype NIFTI_GZ $map

ithresh=2.58
vthresh=1
while [ $1 ]; do
    if [ $1 == "-t" ]; then
	ithresh=$2
	shift 2
    elif [ $1 == "-v" ]; then
	vthresh=$2
	shift 2
    elif [ $1 == "-o" ]; then
	fout=$(remove_ext $2)
	shift 2
    elif [ $1 == "-b" ]; then
	bin=set
	unset idx
	shift
    elif [ $1 == "-c" ]; then
	idx=set
	unset bin
	shift
    elif [ $1 == "-m" ]; then
	table=$2 
	shift 2
    elif [ $1 == "-pos" ]; then
	pos_only=set
	shift
    elif [ $1 == "--debug" ]; then
	debug=set
	shift
    else 
	echo "UNRECOGNIZED ARGUMENT: $1" >&2
	usage
    fi
done

# if -c is selected then use -pos
[ $idx ] && pos_only=set

# determine output filename
if [ ! $fout ]; then
    if [ $idx ]; then
	fout=$map_clusters_idx
    elif [ $bin ]; then
	fout=$map_clusters_bin
    elif [ $table ]; then
	fout=$map_clusters_bins
    else
	fout=$map_clusters
    fi
fi
	
### SETUP
wd=$(mktemp -d "${TMPDIR:-/tmp}/clustertable.XXXX") || mktempfail
[ $debug ] && echo working directory: $wd


### MAIN
if [ $table ]; then
    # produce clusterthresh'd maps according to $table
    i=0;
    while read t v; do
	let i++
	printf "%2d %9.4f %5d\n" $i $t $v
	clusterthresh $map -t $t -v $v -b -o $wd/map$i > /dev/null
    done < <(grep -vE "^ *#|^ *$" $table | sort -n -k 1)  # ignore comments and blank lines
    let n=i

    # merge clusterthresh'd maps
    fslmaths $map -mul 0 $fout
    for i in $(seq 1 $n); do
	fslmaths $wd/map$i -add $fout $fout
    done

    [ $(imtest $fout) != 0 ] && echo made $fout || echo "Something went wrong: $fout not a valid image" >&2

    rm -r $wd
    exit 0
fi

# create indexed image of positive clusters (posclustermap) and list of clusters (posclusterlist)
cluster -i $map -t $ithresh -o $wd/posclustermap > $wd/posclusterlist

# find index of smallest allowable cluster
threshindex=$(awk 'NR==2 {lastindex=$1+1} NR>1 && $2>='$vthresh' {lastindex=$1} END {print lastindex}' $wd/posclusterlist)

# threshold for cluster size (using index of smallest allowable cluster)
# binarize resulting thresholded map
fslmaths $wd/posclustermap -thr $threshindex -bin $wd/clustermask

# repeat procedure on negative intensities
if [ ! $pos_only ]; then
    # invert target map
    fslmaths $map -mul -1 $wd/negmap

    # create indexed image of clusters (negclustermap) and list of clusters (negclusterlist)
    cluster -i $wd/negmap -t $ithresh -o $wd/negclustermap > $wd/negclusterlist

    # find index of smallest allowable cluster
    negthreshindex=$(awk 'NR==2 {lastindex=$1+1} NR>1 && $2>='$vthresh' {lastindex=$1} END {print lastindex}' $wd/negclusterlist)

    # threshold inverted map, binarize, (invert if signed binarization will be done), and combine with thresholded positive map
    fslmaths $wd/negclustermap -thr $negthreshindex -bin $([ $bin ] && echo " -mul -1 ") -add $wd/clustermask $wd/clustermask
fi

# produce output
if [ $idx ]
then  # make map where voxel intensities = cluster indexes, where 1 = largest cluster, 2 = second largest, etc 
    # produce cluster index map (with -o option)
    cluster -i $wd/clustermask -t 1 -o $wd/indexed_backwards >/dev/null
    # invert the index order
    invert_indices $(ls $wd/indexed_backwards*) $wd/indexed
    # move into place (fslmaths to abstract over file type)
    fslmaths $wd/indexed $fout
    echo $wd
elif [ $bin ]
then  # to this point we've been representing our thresholds with making a binarized mask, so no further transformation is necessary
    fslmaths $wd/clustermask $fout
else  # this is the default: multiply the input image by our thresholded (binarized) mask
    fslmaths $map -mul $wd/clustermask $fout
fi

[ $(imtest $fout) == 0 ] && echo "Something went wrong: $fout not a valid image" >&2 && exit 1
echo made $fout

exit 0
