#!/bin/bash
# Author: Luka Ruzic

usage() {
    echo "
USAGE: zview [options] <zstat> [options] [...]
  options given before zstats will apply to all zstats
  options given after a zstat apply only to that zstat
OPTIONS:
   -s
      suppress inverse maps
   -1mm (always a global option)
      resample <zstat> to 1 mm resolution (only works for standard (MNI 2 mm) space images)
   -.5mm (always a global option)
      resample <zstat> to 0.5 mm resolution (only works for standard (MNI 2 mm) space images)
   -t <z threshold>
      use <z threshold> (DEFAULT: 2.58)
   -r
      let image's intensity range determine brightness & contrast
      (min threshold can be overridden by subsequent use of -t)
   --v
      vanilla mode: no max mask overlays, no recognition of binary masks or integer images
    echo
DESCRIPTION:
   - uses average MNI brain (2mm) as background for standard space maps
   - for scanner space maps, looks for example_func or ../example_func
   - coloring: Red-Yellow(activation)/Blue-Lightblue(deactivation), then Cool/Pink, then Yellow/Green
   - if -s is set, colors in order are Red-Yellow,Blue-Lightblue,Green,Pink,Yellow,Cool
   - maps with unspecified colors are copper
   - max masks (generated by mkmaxmasks) are automatically found and overlayed in appropriate colors
   - recognizes binary masks and integer images and displays them appropriately
   - without arguments it'll put up the average MNI brain (2mm)

"
    exit ${1:-1}
}

mktempfail() {
    echo "ERROR: mktemp failed to procure temporary file"
}

if bash --version | grep -q apple; then
    mktempopt="-t zview"
elif bash --version | grep -q linux; then
    mktempopt=""
else
    echo "ERROR: unrecognized bash version, cannot mktemp"
    exit 1
fi


### SET UP DEFAULTS/ENVIRONMENT
MNI_BRAIN_1mm=$(findMNI -1mm)
MNI_BRAIN=$(findMNI)     # path to standard brain
BMIN=2.58               # default min intensity
BMAX=5                  # default max intensity
MMBMIN=0.9
MMBMAX=2.01

# set overlay colors for all overlays beyond the third
COLOR=Copper
i=1; for c in Red-Yellow Blue-Lightblue Pink Cool Yellow Green; do
    COLOR[i++]=$c
done

# set max mask colors (0th color is default)
MMCOLOR=Greyscale
i=1; for c in Blue-Lightblue Red-Yellow Blue-Lightblue Red-Yellow Blue-Lightblue Red-Yellow; do
    MMCOLOR[i++]=$c
done

### PARSE ARGUMENTS
i=0
M=ortho
while [ $1 ]; do    
#    if [ -f ${1%.nii.gz}.nii.gz ]; then
    if [ $(imtest $1) -eq 1 ]; then
	ZSTAT[++i]=$1
	shift
    elif [[ "$1" =~ -help$ ]]; then
	usage 0
    elif [ $1 = "-t" ] && [ $2 ]; then
	if [[ "$2" =~ , ]]; then
	    BMIN[i]=${2%,*}
	    BMAX[i]=${2#*,}
	else
	    BMIN[i]=$2
	    BMAX[i]="$(echo $2 | awk '{if ($1>=0) {if ($1 >= 5) print $1+(5-(($1)%5)); else print 5} else {if ($1 <= -5) print $1+(-5-(($1)%5)); else print -5}}')"
	fi
	shift 2
    elif [ $1 == "-s" ]; then
	NO_INVERSION[i]=set
	shift
    elif [ $1 == "-m" ] || [ $1 == "-l" ]; then
	M=ortho,lightbox
	shift
    elif [ $1 == "-1mm" ]; then
	HIRES=1
	shift
    elif [ $1 == "-.5mm" ]; then
	HIRES=".5"
	shift
    elif [ $1 == "-r" ]; then
	USE_RANGE[i]=set
	BMIN[i]=0
	shift
    elif [ $1 == "-R" ]; then
	USE_ZTHRESH[i]=set
	shift
    elif [ $1 == "--v" ]; then
	VANILLA=set
	shift
    else
	echo "UNRECOGNIZED ARGUMENT: $1"
	usage
    fi
done


WD=$(mktemp -d $mktempopt) || mktempfail


### SELECT ANATOMICAL BACKGROUND IMAGE
# if voxels aren't 2mm in z axis, assume map is subject-specific
# otherwise, assume map is in standard space
if [ ${ZSTAT[1]} ]; then
    pixdims=$(fslinfo ${ZSTAT[1]} | awk '/pixdim[123]/ {printf ("_%.3f",$2)}')
    if [ $HIRES ] || [ $pixdims == "_1.000_1.000_1.000" ]; then
	[ "$HIRES" == ".5" ] && brain=$(findMNI -.5mm)" -b 75,200" || brain=$(findMNI -${HIRES}mm)
    elif [ $pixdims == "_2.000_2.000_2.000" ]; then
	brain=$(findMNI)
    else
	if [ -f $(dirname ${ZSTAT[1]})/example_func.nii.gz ]; then
	    example_func=$WD/exampel_func.nii.gz; cp $(dirname ${ZSTAT[1]})/example_func.nii.gz $example_func
	elif [ -f $(dirname ${ZSTAT[1]})/../example_func.nii.gz ]; then
	    example_func=$WD/exampel_func.nii.gz; cp $(dirname ${ZSTAT[1]})/../example_func.nii.gz $example_func
	else
	    echo "ERROR: ${ZSTAT[1]} appears to be in scanner space, but example_func cannot be found"
	    usage
	fi
	brain="$example_func"
    fi
else
    brain="$MNI_BRAIN"
fi

### PREPARE STRING FOR FSLVIEW
i=0; for ((z=1;z<=${#ZSTAT[*]};z++)); do
    # setup
    let i++
    [ ! $VANILLA ] && [ ! $HIRES ] && [ -f ${ZSTAT[z]%.nii.gz}_max_mask.nii.gz ] && max_mask=${ZSTAT[z]%.nii.gz}_max_mask.nii.gz || unset max_mask

    ### CATCH CERTAIN KINDS OF IMAGES
    if [ $VANILLA ]; then
	overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b ${BMIN[z]:-$BMIN},${BMAX[z]:-$BMAX}"
    else
	fslmaths ${ZSTAT[z]} -mul -1 $WD/inverse    
	if [ $(fslstats ${ZSTAT[z]} -V | awk '{print $1}') -ne 0 ]\
           &&[ $(cluster -i ${ZSTAT[z]} -t 1 | awk 'NR>1 {print $3%1}' | grep -c '\.') -eq 0 ]\
           &&[ $(cluster -i $WD/inverse -t 1 | awk 'NR>1 {print $3%1}' | grep -c '\.') -eq 0 ]
	then  # image has non-zeros, peaks are all integers (first pass test for integer image)
	    bintest=$(fslstats ${ZSTAT[z]} -R | awk '$1==0 && $2==1 {print "bin"; next} $1==-1 && $2==1 {print "negandpos";next} {print "none"}')
	    if [ "$bintest" != "none" ]
	    then  # it's a binarized mask
		if [ $HIRES ]; then
		    hiresify ${ZSTAT[z]} $WD/$(basename ${ZSTAT[z]}) -$HIRES
		    ZSTAT[z]=$WD/$(basename ${ZSTAT[z]})
		fi
		overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b 0,5"
		if [ "$bintest" == "negandpos" ]
		then  # it has -1s as well as 1s and 0s
		    let i++
		    overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b 0,-5"
		fi
		continue
	    else  # it might be a cluster indexed image (all integers)
		ascii=$(mktemp $mktempopt) || mktempfail
		fsl2ascii ${ZSTAT[z]} $ascii
		if [ $(awk '{for (i=1;i<=NF;i++) print $i%1}' ${ascii}00000 | grep -c '\.') -eq 0 ]
		then # all values are integers
		    echo "FOUND INTEGER IMAGE $ZSTAT[${z}]: ignoring any/all other images"
		    if [ $HIRES ]; then hiresify ${ZSTAT[z]} $WD/$(basename ${ZSTAT[z]}) -$HIRES; ZSTAT[z]=$WD/$(basename ${ZSTAT[z]}); fi
		    overlay="${ZSTAT[z]} -l Random-Rainbow -b "$(fslstats ${ZSTAT[z]} -R | awk '{print $1","$2}')
		    break
		fi
	    fi
	fi
    ### IF IT'S NOT A SPECIAL IMAGE, PROCEED AS CONFIGURED
	if [ $USE_RANGE ] || [ ${USE_RANGE[z]} ]; then
	    if [ $HIRES ]; then
		hiresify ${ZSTAT[z]} $WD/$(basename ${ZSTAT[z]}) -$HIRES
		ZSTAT[z]=$WD/$(basename ${ZSTAT[z]})
		if [ $max_mask ]; then
		    hiresify $max_mask $WD/$(basename $max_mask) -$HIRES
		    max_mask=$WD/$(basename $max_mask)
		fi
	    fi
	    
	    range=($(fslstats ${ZSTAT[z]} -R))
	    rangetype=($(echo ${range[*]} | awk '{if($2>0) {if($1>=0) print "POS"; else print "BOTH"} else print "NEG"}'))
	    case $rangetype in
		"POS")
		    overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b "$(echo ${BMIN[z]:-$BMIN} ${range[1]} | awk '{OFS=","; if($2<$1) print $1,$1; else print $1,$2}')
		    [ $max_mask ] && overlay+=" $max_mask -l ${MMCOLOR[i]:-$MMCOLOR} -b $MMBMIN,$MMBMAX"
		    ;;
		
		"NEG")
		    if [ ! $NO_INVERSION ] && [ ! ${NO_INVERSION[z]} ]; then
			let i++
			overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b "$(echo -${BMIN[z]:-$BMIN} ${range[0]} | awk '{OFS=","; if ($2>$1) print $1,$1; else print $1,$2}')
			[ $max_mask ] && overlay+=" $max_mask -l ${MMCOLOR[i]:-$MMCOLOR} -b -$MMBMIN,-$MMBMAX"
		    fi
		    ;;
		
		"BOTH")
		    overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b "$(echo ${BMIN[z]:-$BMIN} ${range[1]} | awk '{OFS=","; if($2<$1) print $1,$1; else print $1,$2}')
		    [ $max_mask ] && overlay+=" $max_mask -l ${MMCOLOR[i]:-$MMCOLOR} -b $MMBMIN,$MMBMAX"
		    if [ ! $NO_INVERSION ] && [ ! ${NO_INVERSION[z]} ]; then
			let i++
			overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b "$(echo -${BMIN[z]:-$BMIN} ${range[0]} | awk '{OFS=","; if ($2>$1) print $1,$1; else print $1,$2}')
			[ $max_mask ] && overlay+=" $max_mask -l ${MMCOLOR[i]:-$MMCOLOR} -b -$MMBMIN,-$MMBMAX"
		    fi
		    ;;
	    esac
	else
            # overlay image (normal settings)
	    if [ $HIRES ]; then
		hiresify ${ZSTAT[z]} $WD/$(basename ${ZSTAT[z]}) -$HIRES
		ZSTAT[z]=$WD/$(basename ${ZSTAT[z]})
		if [ $max_mask ]; then
		    hiresify $max_mask $WD/$(basename $max_mask) -$HIRES
		    max_mask=$WD/$(basename $max_mask)
		fi
	    fi

	    overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b ${BMIN[z]:-$BMIN},${BMAX[z]:-$BMAX}"
	    [ $max_mask ] && overlay+=" $max_mask -l ${MMCOLOR[i]:-$MMCOLOR} -b $MMBMIN,$MMBMAX"
	    # overlay inverted image if desired
	    if [ ! $NO_INVERSION ] && [ ! ${NO_INVERSION[z]} ]; then
		let i++
		overlay+=" ${ZSTAT[z]} -l ${COLOR[i]:-$COLOR} -b -${BMIN[z]:-$BMIN},-${BMAX[z]:-$BMAX}"
		[ $max_mask ] && overlay+=" $max_mask -l ${MMCOLOR[i]:-$MMCOLOR} -b -$MMBMIN,-$MMBMAX"
	    fi
	fi
    fi
done

### CALL FSLVIEW
CMD="fslview -m $M $brain $overlay"
echo $CMD
eval $CMD 2> /dev/null


exit 0
